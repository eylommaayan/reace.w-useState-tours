ביישום React, הרינדור הראשוני הוא הפעם הראשונה שבה עץ הרכיבים מעובד ל-DOM. זה קורה כאשר היישום נטען לראשונה, או כאשר רכיב הבסיס מעובד לראשונה. זה ידוע גם כ"הרכבה" של הרכיבים.

רינדורים חוזרים, לעומת זאת, מתרחשים כאשר מצב הרכיב או המאפיינים שלו משתנים, ויש לעדכן את הרכיב ב-DOM כדי לשקף שינויים אלה. React משתמש ב-DOM וירטואלי כדי לייעל את תהליך עדכון ה-DOM בפועל, כך שרק השינויים הדרושים מתבצעים.

ישנן מספר דרכים בהן ניתן להפעיל רינדור חוזר ברכיב React:

- על ידי שינוי מצב הרכיב או המאפיינים שלו. כאשר מצב הרכיב או המאפיינים שלו משתנים, React יבצע רינדור מחדש של הרכיב כדי לשקף שינויים אלה.

- כאשר רכיב האב מעובד מחדש, גם אם מצב הרכיב או המאפיינים שלו לא השתנו.

#### כללים כלליים של Hooks (ווים)

- מתחיל ב-"use" (גם -react וגם hooks מותאמים אישית)
- הרכיב חייב להיות באותיות גדולות
- קריאה בתוך גוף הפונקציה/רכיב הרכיב
- אין לקרוא ל-hooks באופן מותנה (לכסות מאוחר יותר)
- הגדרת פונקציות לא מעדכנת את המצב באופן מיידי (לכסות מאוחר יותר)

# מטרת `useEffect` (בקצרה)

* **אפקט צד אחרי רנדר**: מפעיל קוד שצריך לקרות *לאחר* שה־UI צויר (API, טיימרים, מנויים, גישה ל־localStorage/DOM).
* **מניעת לולאות**: לא מעדכנים סטייט בזמן הרנדר; עושים זאת בתוך `useEffect` כדי למנוע רנדר → setState → רנדר…
* **שליטה מתי לרוץ**:

  * `[]`—רץ פעם אחת ב־mount.
  * `[dep]`—רץ בכל שינוי של `dep`.
* **ניקוי (Cleanup)**: מחזירים פונקציה מהאפקט לביטול בקשות/טיימרים/מנויים כשהקומפוננטה מתפרקת.

# איך זה מיושם בפרויקט שלך

* ב־`App.jsx`:

  ```jsx
  useEffect(() => {
    setTours(toursData);  // "טעינת" דאטה (מקומי) – מדמה API
    setLoading(false);    // סיום מצב טעינה
  }, []);
  ```
* המשמעות:

  * ברנדר ראשון מוצג `<Loading />` (כי `loading=true`).
  * אחרי הרנדר, האפקט “מביא” נתונים (כאן מקובץ) ומכבה `loading`.
  * מתבצע רנדר שני שמציג את רשימת הסיורים.

# הסבר הפרויקט ושימוש בו (זרימת עבודה)

* **מצבים (state)**:

  * `loading` (מרמת `App`) – מציג ספינר עד להגעת נתונים.
  * `tours` (מרמת `App`) – מאגר הסיורים.
  * `readMore` (מרמת `Tour`) – מציג/מקפל תיאור ארוך לכל כרטיס.
* **תצוגה מותנית**:

  * `loading` → `<Loading />`
  * אין סיורים → מסך “לא נשארו טיולים” + כפתור “רענון”
  * יש סיורים → `<Tours />` שמרנדר כרטיסי `<Tour />`
* **אינטראקציות**:

  * “לא מעוניין” מסיר כרטיס בעזרת `setTours(prev => prev.filter(...))`.
  * “read more / show less” מציג/מקפל טקסט לכל כרטיס.
* **ארכיטקטורה נקייה**:

  * `App`—לוגיקה וסטייט עליון.
  * `Tours`—רשימה.
  * `Tour`—כרטיס יחיד.
  * `Loading`—מצב טעינה.

# למה `useEffect` חשוב כאן

* נותן **מחזור חיים אמיתי**: טעינה → נתונים → UI.
* מאפשר להחליף את המקור המקומי ל־`fetch` אמיתי בלי לשנות את מבנה ה־UI.
* שומר על רנדר “טהור” ומונע לולאות/באגים.

# שדרוג מהיר (אם תרצה בהמשך)

* להחליף ל־`fetch('/tours-he.json')` + `AbortController` ב־cleanup.
* להוסיף טיפול שגיאות (`error` state) והודעת שגיאה ידידותית.




זהו—`useEffect` = המקום לטעינה/תופעות צד אחרי שהמסך עלה; בפרויקט שלך הוא מדמה API, ממלא את הנתונים ומעביר את האפליקציה מ־Loading לתצוגת הסיורים בצורה נקייה ובטוחה.

<img width="1677" height="953" alt="image" src="https://github.com/user-attachments/assets/33febf74-c36a-4dd5-b6f2-1d57f0fa375c" />

